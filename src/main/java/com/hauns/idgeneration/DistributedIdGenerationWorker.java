package com.hauns.idgeneration;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Random;

public class DistributedIdGenerationWorker {
  private static final long TWEPOCH = 1288834974657L;

  private static final long WORKER_ID_BITS = 10L;
  private static final long MAX_WORKER_ID = ~(-1L << WORKER_ID_BITS);
  private static final long SEQUENCE_BITS = 12L;

  private static final long SEQUENCE_BITS1 = SEQUENCE_BITS;
  private static final long TIMESTAMP_LEFT_SHIFT = SEQUENCE_BITS + WORKER_ID_BITS;
  private static final long SEQUENCE_MASK = ~(-1L << SEQUENCE_BITS);
  private final Random random = new Random();
  private long workerId = 0;
  private long sequence = 0L;
  private long lastTimestamp = -1L;

  public DistributedIdGenerationWorker() {
    byte[] address;
    try {
      address = InetAddress.getLocalHost().getAddress();
    } catch (UnknownHostException e) {
      address = null;
    }
    // Worker id is generated by hashing of ip address which is unique in a local network, or random
    // if unavailable.
    if (address != null) {
      for (byte x : address) {
        workerId = ((workerId << 8) - (Byte.MIN_VALUE & 0xff) + x) & MAX_WORKER_ID;
      }
    } else {
      workerId = random.nextLong() & MAX_WORKER_ID;
    }
  }

  public synchronized long nextId() {
    long timestamp = timeGen();

    if (timestamp < lastTimestamp) {
      throw new DistributedIdGeneratorException(
          String.format(
              "Clock moved backwards. Refusing to generate id for %d milliseconds",
              lastTimestamp - timestamp));
    }

    if (lastTimestamp == timestamp) {
      sequence = (sequence + 1) & SEQUENCE_MASK;
      if (sequence == 0) {
        timestamp = tilNextMillis(lastTimestamp);
      }
    } else {
      sequence = 0;
    }

    lastTimestamp = timestamp;
    return ((timestamp - TWEPOCH) << TIMESTAMP_LEFT_SHIFT)
        | (workerId << SEQUENCE_BITS1)
        | sequence;
  }

  private long tilNextMillis(long lastTimestamp) {
    long timestamp = timeGen();
    while (timestamp <= lastTimestamp) {
      timestamp = timeGen();
    }
    return timestamp;
  }

  private long timeGen() {
    return System.currentTimeMillis();
  }
}
